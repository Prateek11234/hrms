HRMS LITE - COMPLETE BUILD PROCEDURE (END-TO-END)
=================================================

This document explains, in detail, the full process followed to build the HRMS Lite application in this repository. 
It covers:
- Project setup decisions
- Backend stack, architecture, models, API design, validation, and error handling
- Frontend stack, routing, UI components, state management, and UX decisions
- Configuration, environment variables, and deployment-related files
- Small but important implementation details that make the app production-friendly

The goal is to give a reviewer enough insight to understand *exactly* how and why everything was built, step by step.


1. HIGH-LEVEL ARCHITECTURE AND GOALS
------------------------------------

1.1. Functional goals from the assignment
----------------------------------------

The assignment required a lightweight Human Resource Management System (HRMS Lite) with:

- Employee Management:
  - Add employee with fields:
    - Employee ID (unique)
    - Full Name
    - Email Address
    - Department
  - View list of all employees
  - Delete employee

- Attendance Management:
  - Mark attendance for an employee with:
    - Date
    - Status (Present / Absent)
  - View attendance records for each employee

Additional non-functional expectations:
- RESTful APIs
- Persistent database (SQL or NoSQL)
- Proper validations and error handling
- Clean, professional, production-like UI
- Meaningful loading/empty/error states
- Deployed frontend + deployed backend + GitHub repo


1.2. Chosen overall architecture
--------------------------------

We chose a classic full-stack architecture:

- Backend: FastAPI (Python) + SQLModel + SQLite
- Frontend: React + TypeScript + Vite
- Deployment strategy: 
  - Backend: ready to run via `uvicorn` or a Docker container (for platforms like Render/Railway).
  - Frontend: built as a static SPA, suitable for Vercel/Netlify (with routing-friendly config).

Rationale:
- FastAPI is very strong for rapid, well-typed REST API development with excellent validation out of the box using Pydantic.
- SQLModel is built on top of SQLAlchemy and Pydantic, giving a simple and expressive way to define models using type hints, and works well with SQLite.
- SQLite keeps the setup simple while still being a real SQL database; the DATABASE_URL is configurable, so a different DB can be used later.
- React + Vite + TypeScript offers:
  - Fast dev server
  - Strong typing on the frontend
  - Great DX for building a small but professional admin UI


1.3. Repository layout
----------------------

From the root (`hrms lite/`):

- `backend/`
  - `app/`
    - `__init__.py`        - marks the folder as a Python package
    - `db.py`              - central database engine and session management
    - `models.py`          - SQLModel ORM models for Employee and Attendance
    - `schemas.py`         - Pydantic request/response schemas and shared enums
    - `main.py`            - FastAPI app instance, routes, error handlers, and business logic
  - `.env.example`         - example env file with default DATABASE_URL and CORS origins
  - `requirements.txt`     - backend Python dependencies
  - `Dockerfile`           - container image for backend deployment
  - `.dockerignore`        - excludes local env/DB files from the build context

- `frontend/`
  - `index.html`           - Vite entry HTML with React app mount point
  - `vite.config.ts`       - Vite config, including React plugin
  - `.env.example`         - example env with VITE_API_BASE_URL
  - `public/_redirects`    - Netlify SPA routing configuration
  - `vercel.json`          - Vercel SPA rewrite configuration
  - `package.json`         - frontend dependencies and scripts
  - `tsconfig.json`        - TypeScript configuration (strict, bundler mode)
  - `src/`
    - `main.tsx`           - React render entry, wraps app with router
    - `App.tsx`            - top-level layout, navigation, and routes
    - `style.css`          - global styling (layout, typography, components)
    - `api/`
      - `http.ts`          - generic HTTP client wrapper and error class
      - `hrms.ts`          - typed API client for HRMS endpoints
    - `components/`
      - `ToastProvider.tsx` - global toast notification provider
    - `pages/`
      - `DashboardPage.tsx`  - shows basic metrics (bonus requirement)
      - `EmployeesPage.tsx`  - list employees + create employee form
      - `AttendancePage.tsx` - per-employee attendance view and mark form

- Root:
  - `README.md`            - project overview, stack, commands, deployment guide
  - `.gitignore`           - ignores build artifacts, databases, env files, node_modules
  - `procedure.txt`        - the current document


2. BACKEND IMPLEMENTATION (FASTAPI + SQLMODEL)
---------------------------------------------

2.1. Backend dependency setup
-----------------------------

Created `backend/requirements.txt` with the main libraries:

- `fastapi`:
  - Provides the web framework, routing, dependency injection.
  - Integrates with Pydantic for validation.

- `uvicorn[standard]`:
  - ASGI server used to run the FastAPI application in production or locally.
  - `[standard]` extras bring support tools like `httptools`, `uvloop`, `watchfiles`, etc.

- `sqlmodel`:
  - Combines SQLAlchemy ORM behavior with Pydantic’s type system.
  - Allows defining models once and using them both for database tables and validation (where appropriate).

- `email-validator`:
  - Used by Pydantic `EmailStr` to validate email formats robustly.

- `python-dotenv`:
  - Allows `.env` file values to be loaded into environment variables automatically.


2.2. Environment configuration file
-----------------------------------

Created `backend/.env.example`:
- `DATABASE_URL=sqlite:///./hrms.db`
  - Defaults to a SQLite database file `hrms.db` in the `backend/` directory.
  - Uses three slashes (`./`) for a relative path.
- `CORS_ORIGINS=http://localhost:5173`
  - Default allowed origin for the frontend dev server.

Intended workflow:
- Copy `.env.example` to `.env`.
- Adjust values for local runs or deployment (e.g., change DB or CORS origins).


2.3. Database engine and session management (`db.py`)
----------------------------------------------------

File: `backend/app/db.py`

Key elements:
- `_build_engine()`:
  - Reads `DATABASE_URL` from the environment using `os.getenv`.
  - Defaults to `sqlite:///./hrms.db`.
  - Applies `connect_args = {"check_same_thread": False}` if using SQLite:
    - SQLite, by default, restricts DB connections to a single thread. Since FastAPI and uvicorn can serve across threads, this flag ensures that the connection can be shared safely in that environment (recommended by SQLAlchemy docs).
  - Returns a `create_engine` instance from SQLModel/SQLAlchemy.

- `engine`:
  - Module-level engine object used by the rest of the application.

- `init_db()`:
  - Calls `SQLModel.metadata.create_all(engine)` to:
    - Create all declared tables if they do not already exist.
    - This is executed once at application startup (see `@app.on_event("startup")`).

- `get_session()`:
  - A generator function using `with Session(engine) as session`.
  - Yield pattern integrates with FastAPI’s dependency injection:
    - When a route depends on `Session = Depends(get_session)`, FastAPI:
      - Creates a session at the start of the request.
      - Injects it into the endpoint function.
      - Ensures it is closed after the request.


2.4. Database models (`models.py`)
----------------------------------

File: `backend/app/models.py`

Defined using SQLModel:

2.4.1. AttendanceStatus enum
----------------------------

`AttendanceStatus` is an `Enum` subclass of `str`, with two allowed values:
- `"Present"`
- `"Absent"`

Why string-based Enum?
- Aligns with human-readable values seen in the DB and API responses.
- Works well with JSON serialization (strings instead of integer codes).


2.4.2. Employee model
---------------------

`class Employee(SQLModel, table=True):`

Fields:
- `id: Optional[int]`:
  - Primary key, auto-increment integer.
  - Set as `primary_key=True`.

- `employee_id: str`:
  - Unique business identifier.
  - Indexed in the DB.
  - `nullable=False`
  - Has length constraints via `min_length=1`, `max_length=50`.
  - Marked `unique=True` at DB level to ensure uniqueness.

- `full_name: str`:
  - Required name field.
  - `min_length=1`, `max_length=120`.

- `email: str`:
  - Stored as lowercase string.
  - Indexed and `unique=True`.
  - DB-level uniqueness constraint prevents duplicate emails.

- `department: str`:
  - Required department name, with length constraints.

- `created_at: datetime`:
  - Defaulted using `datetime.now(timezone.utc)`.
  - Captures when the employee record was created.

Design notes:
- The combination of Pydantic-level (schema) validation and DB-level uniqueness ensures robust handling of duplicates.
- `employee_id` and `email` are both unique fields to match the typical HR constraints (one employee per ID and per email).


2.4.3. Attendance model
-----------------------

`class Attendance(SQLModel, table=True):`

Additional `__table_args__`:
- `UniqueConstraint("employee_pk", "date", name="uq_attendance_employee_date")`
  - Ensures only one attendance record per employee per date can exist.

Fields:
- `id: Optional[int]`:
  - Primary key, auto-increment.

- `employee_pk: int`:
  - Foreign key referencing `employee.id`.
  - `index=True` for faster lookups by employee.

- `date: date`:
  - The calendar date the attendance refers to.
  - `index=True` for date-range queries and filters.

- `status: AttendanceStatus`:
  - Enum field (`Present` or `Absent`).

- `created_at: datetime`:
  - Time the attendance record was created.

Design notes:
- Instead of embedding attendance as nested structure inside employee documents (like in NoSQL), we use a relational model that supports queries like:
  - All attendance for an employee.
  - Filter by date range and status.


2.5. API schemas (`schemas.py`)
-------------------------------

File: `backend/app/schemas.py`

We separate transport schemas (what we send/receive over HTTP) from database models. This helps:
- Avoid accidental exposure of internal IDs or DB-specific fields.
- Keep strict control over what can be written and what is read back.

Defined with Pydantic `BaseModel`:

- `EmployeeCreate`:
  - Input for creating employees.
  - Uses:
    - `employee_id: str`
    - `full_name: str`
    - `email: EmailStr` (from Pydantic, leveraging `email-validator`)
    - `department: str`
  - Length validation for strings and email format validation.

- `EmployeeRead`:
  - Output representation for employee responses.
  - Contains:
    - `employee_id`
    - `full_name`
    - `email`
    - `department`
    - `created_at`
  - Does NOT expose the internal numeric `id` field.

- `AttendanceCreate`:
  - Input for marking attendance.
  - Fields:
    - `date: date`
    - `status: AttendanceStatus`

- `AttendanceRead`:
  - Output for attendance entries.
  - Fields:
    - `date`
    - `status`
    - `created_at`

- `DashboardRead`:
  - Used by the dashboard endpoint.
  - Fields:
    - `employee_count`
    - `attendance_records`
    - `today_present`
    - `today_absent`
    - `today_date`

- `ErrorResponse`:
  - Optional helper shape: `detail: str`, `code: Optional[str]`
  - Useful for consistent error responses (though FastAPI’s built-in structure is also used).


2.6. FastAPI application and routes (`main.py`)
-----------------------------------------------

File: `backend/app/main.py`

2.6.1. App initialization
-------------------------

- Environment:
  - `load_dotenv()` is called at module import time so `.env` variables become available via `os.getenv`.

- CORS handling:
  - `_parse_cors_origins()`:
    - Reads `CORS_ORIGINS` (comma-separated).
    - Trims whitespace, removes empty entries.
    - Defaults to `["http://localhost:5173"]` if nothing configured.

- `app = FastAPI(title="HRMS Lite API", version="1.0.0")`
  - Defines the main application instance.

- `app.add_middleware(CORSMiddleware, ...)`:
  - `allow_origins`: from `_parse_cors_origins()`.
  - `allow_credentials=True`
  - `allow_methods=["*"]`
  - `allow_headers=["*"]`
  - This permits the frontend to call the backend without CORS errors in both dev and production (provided the correct origins are configured).

- Startup:
  - `@app.on_event("startup")`:
    - `init_db()` is called.
    - Ensures all tables exist at server startup.


2.6.2. Custom validation error handler
--------------------------------------

`@app.exception_handler(RequestValidationError)`

- By default, FastAPI returns detailed JSON with nested `loc` and `msg` entries for validation errors.
- Here, we:
  - Iterate through `exc.errors()`; for each:
    - Build a human-readable `loc` string (e.g. "employee_id" or "body.employee_id").
    - Combine field location and message into a short string: `"employee_id: field required"`.
  - Join them with `" | "` to form a single message.
  - Return `JSONResponse(status_code=422, content={"detail": "..."})`.

Reason:
- Makes it easy for the frontend to display a clean error toast / message instead of deeply nested structures.


2.6.3. Health endpoint
----------------------

`GET /health`
- Returns simple JSON: `{"ok": True}`
- Used only as a sanity-check endpoint for monitoring or scribble tests.


2.6.4. Helper functions
-----------------------

- `_get_employee_or_404(session, employee_id)`:
  - Executes `select(Employee).where(Employee.employee_id == employee_id)`.
  - If not found, raises:
    - `HTTPException(status_code=404, detail="Employee not found")`.

- `_employee_to_read(emp)`:
  - Converts an `Employee` ORM instance into `EmployeeRead` schema.
  - Avoids leaking internal `id`.


2.6.5. Employee endpoints
-------------------------

1) `POST /employees`
   - Request body: `EmployeeCreate`.
   - Response: `EmployeeRead`.
   - Status code: `201 Created`.

   Steps:
   - Trim whitespace from fields and lowercase email.
   - Check that none of these are empty (defense-in-depth beyond Pydantic):
     - `employee_id`, `full_name`, `department`, `email`.
   - Query DB for duplicates:
     - `existing = session.exec(select(Employee).where((Employee.employee_id == employee_id) | (Employee.email == email))).first()`
   - If `existing` found:
     - If same `employee_id` -> raise `409 Conflict` with detail `"Employee ID already exists"`.
     - Else -> raise `409 Conflict` with detail `"Email already exists"`.
   - If no duplicate:
     - Create new `Employee` instance.
     - `session.add(emp)` and `commit`.
     - Wrap commit in try/except `IntegrityError`:
       - If DB-level uniqueness throws, raise `409 Conflict` with `"Duplicate employee (employee_id or email)"`.
     - `session.refresh(emp)` to get DB-generated fields (like `id`, `created_at`).
   - Return `_employee_to_read(emp)` object.

   Outcome:
   - Prevents duplicates both at application and DB levels.
   - Ensures nice error codes for the frontend.


2) `GET /employees`
   - Response: `List[EmployeeRead]`.
   - Steps:
     - Run `select(Employee).order_by(Employee.created_at.desc())`.
     - Convert each to `EmployeeRead`.
   - Used by frontend Employees page to populate the employees table.


3) `DELETE /employees/{employee_id}`
   - Path parameter: `employee_id` (string, length 1–50).
   - Uses `_get_employee_or_404` to verify the employee exists.
   - Deletes all attendance rows for that employee:
     - `session.exec(delete(Attendance).where(Attendance.employee_pk == emp.id))`.
   - Deletes employee record itself: `session.delete(emp)`.
   - `session.commit()`.
   - Returns `Response(status_code=204)` (no content).

   Reason:
   - Deleting attendance first avoids orphan foreign keys.
   - `204` clearly signals success with no response body.


2.6.6. Attendance endpoints
---------------------------

1) `POST /employees/{employee_id}/attendance`
   - Path: `{employee_id}` (string).
   - Body: `AttendanceCreate` (date + status).
   - Response: `AttendanceRead`.
   - Status code: `201 Created`.

   Steps:
   - Use `_get_employee_or_404` to confirm employee exists.
   - Check if an attendance record already exists for this `employee_pk` + `date`:
     - `existing = session.exec(select(Attendance).where(Attendance.employee_pk == emp.id, Attendance.date == payload.date)).first()`
   - If existing:
     - Raise `409 Conflict` with `"Attendance already marked for this date"`.
   - Otherwise:
     - Create `Attendance` object.
     - Add and commit within a try/except `IntegrityError` (to catch any DB uniqueness violations).
     - Refresh and return `AttendanceRead`.


2) `GET /employees/{employee_id}/attendance`
   - Query parameters:
     - `start_date: Optional[date]`
     - `end_date: Optional[date]`
     - `status_filter: Optional[AttendanceStatus]` (aliased as `status` in query string).
   - Response: `List[AttendanceRead]`.

   Steps:
   - Confirm employee exists with `_get_employee_or_404`.
   - Build a SQLModel `select` query:
     - Base filter: `Attendance.employee_pk == emp.id`.
     - If `start_date` provided: `Attendance.date >= start_date`.
     - If `end_date` provided: `Attendance.date <= end_date`.
     - If `status_filter` provided: `Attendance.status == status_filter`.
   - Order results by `Attendance.date.desc()`.
   - Execute and map each row to `AttendanceRead`.

   This endpoint supports:
   - Viewing all records for an employee.
   - Bonus features:
     - Filtering by date range.
     - Filtering by Present/Absent.


2.6.7. Dashboard endpoint (bonus)
---------------------------------

`GET /dashboard`
Response: `DashboardRead`.

Logic:
- Determine `today = date.today()`.
- Compute:
  - `employee_count`:
    - `select(func.count()).select_from(Employee)`.
  - `attendance_records`:
    - `select(func.count()).select_from(Attendance)`.
  - `today_present`:
    - `select(func.count()).select_from(Attendance).where(Attendance.date == today, Attendance.status == AttendanceStatus.present)`.
  - `today_absent`:
    - Similarly, but for `AttendanceStatus.absent`.
- Return counts + `today_date`.

Advantage:
- Cards on the dashboard can display:
  - Number of employees
  - Total attendance records
  - Today present count
  - Today absent count


2.7. Backend Dockerfile and .dockerignore
-----------------------------------------

`backend/Dockerfile`:
- Base image: `python:3.11-slim`
- `WORKDIR /app`
- Set environment:
  - `PYTHONDONTWRITEBYTECODE=1`
  - `PYTHONUNBUFFERED=1`
- Copy `requirements.txt` and run `pip install --no-cache-dir -r requirements.txt`.
- Copy `app/` code to `/app/app`.
- Set default `DATABASE_URL=sqlite:////app/hrms.db`.
  - Four slashes means an absolute path `/app/hrms.db` inside the container.
- Command:
  - `uvicorn app.main:app --host 0.0.0.0 --port ${PORT:-8000}`
  - Uses `$PORT` if provided by hosting, otherwise 8000.

`.dockerignore`:
- Excludes:
  - `__pycache__`, `*.pyc`, `venv/`, `.venv/`
  - `.env`
  - `*.db`
- Keeps the image clean and avoids bundling secrets / local DB into the image.


2.8. Backend quick tests executed during development
----------------------------------------------------

- Ran small Python snippets using `python -c` inside `backend/` to:
  - Initialize DB using `init_db()`.
  - Insert a test employee.
  - Check that a duplicate employee_id triggers `IntegrityError`.
- Compiled Python modules with `python -m py_compile` to:
  - Catch syntax errors early: `main.py`, `db.py`, `models.py`, `schemas.py`.


3. FRONTEND IMPLEMENTATION (REACT + TYPESCRIPT + VITE)
------------------------------------------------------

3.1. Vite + React-TS scaffold
-----------------------------

Used:
- `npm create vite@latest frontend -- --template react-ts`

This generated:
- A minimal TypeScript + Vite project with:
  - `index.html`
  - `src/main.ts` and `src/counter.ts` (demo counter)
  - `src/style.css` with default Vite styles
  - `tsconfig.json` configured for bundler mode
  - `package.json` with dev dependencies for TypeScript and Vite

We then adapted it:
- Installed React + ReactDOM + React Router dependencies.
- Replaced the vanilla script entry with a React component tree.
- Removed demo files (`counter.ts`, example SVG).


3.2. Frontend dependencies and config
-------------------------------------

`frontend/package.json`:
- Added dependencies:
  - `react`
  - `react-dom`
  - `react-router-dom`

- Added dev dependencies:
  - `@types/react`
  - `@types/react-dom`
  - `@vitejs/plugin-react-swc` (for fast React builds)

`vite.config.ts`:
- Added:
  - `import react from '@vitejs/plugin-react-swc'`
  - `plugins: [react()]`
  - Configured dev server port: `5173` (common default and matches README).

`tsconfig.json`:
- Ensured:
  - `"jsx": "react-jsx"` (new JSX transform).
  - `"moduleResolution": "bundler"`.
  - Strict TypeScript flags: `"strict": true`, `noUnusedLocals`, `noUnusedParameters`, etc.
- These settings ensure the codebase is type-safe and that unused imports/variables are flagged.


3.3. Frontend environment variables
-----------------------------------

`frontend/.env.example`:
- `VITE_API_BASE_URL=http://localhost:8000`
  - This tells the frontend where to call the backend.
  - On deployment, this will be set to the deployed backend URL.

Why use env:
- Allows local, staging, and production APIs to be swapped without code changes.


3.4. Entry HTML and app mount
-----------------------------

`frontend/index.html`:
- `<div id="app"></div>` is the root container.
- `<script type="module" src="/src/main.tsx"></script>` loads the React entry file.
- `<title>HRMS Lite</title>` sets the browser tab title.


3.5. React entry file (`main.tsx`)
----------------------------------

`frontend/src/main.tsx`:

- Imports:
  - React + ReactDOM
  - `BrowserRouter` from `react-router-dom`
  - `App` root component
  - Global stylesheet `style.css`

- Renders:
  - `ReactDOM.createRoot(document.querySelector<HTMLDivElement>('#app')!)`
  - Wraps `<App />` with:
    - `<React.StrictMode>` (helps detect potential issues in dev).
    - `<BrowserRouter>` for SPA routing.


3.6. Global styling (`style.css`)
---------------------------------

The original Vite demo styles were replaced with a custom design tailored to:
- Dark, modern admin UI look.
- Consistent typography, spacing, and reusable layout primitives.

Key aspects:
- CSS custom properties (`:root`) define:
  - Colors for background, panels, text, muted text, borders, primary/emphasis colors (blue, green, red), box shadows.
- Body background:
  - Multiple layered radial gradients for soft colored glows.
- Layout classes:
  - `.container` for max-width, padding.
  - `.topbar` for brand + navigation layout.
  - `.brand`, `.brandTitle`, `.brandSub` for header text.
  - `.nav` and `.nav a.active` for navigation styling and active state.
- Card and table styling:
  - `.card`, `.cardHeader`, `.cardBody` for panel look and spacing.
  - `.tableWrap` for scrollable tables with rounded corners.
  - `table`, `th`, `td` for sleek table UI.
- Form UI:
  - `.field`, `.label` for form groups and labels.
  - `input`, `select` for consistent inputs, with focus outlines and placeholder colors.
- Buttons:
  - `.btn`, `.btnPrimary`, `.btnDanger` with subtle hover animations, disabled state styling.
- Pills for attendance status:
  - `.pill`, `.pillPresent`, `.pillAbsent` for Present/Absent indicators.
- Toast notifications:
  - `.toast`, `.toastTitle`, `.toastBody` for small overlay messages in the lower right corner.

Media queries:
- For narrower screens, `.grid` switches from two columns to one.

All pages share this single `style.css` to ensure consistency.


3.7. HTTP utility: `api/http.ts`
--------------------------------

Responsibilities:
- Provide a generic `apiFetch` function that wraps `fetch`.
- Encapsulate:
  - Base URL logic.
  - JSON encoding/decoding.
  - Error handling and mapping to `ApiError`.

Key elements:
- `ApiError` class:
  - Extends `Error`.
  - Stores `status` (HTTP status code) and optionally `body`.
  - Used to differentiate between network/API errors and generic JS errors.

- `getApiBaseUrl()`:
  - Reads `VITE_API_BASE_URL` from `import.meta.env`.
  - Trims trailing slashes.
  - Defaults to `http://localhost:8000` if not set.
  - Displayed in the UI for debugging so the admin can see which API endpoint is being targeted.

- `safeReadJson(res)`:
  - Checks the `Content-Type` header to see if it includes `application/json`.
  - If yes, tries to parse `res.json()`, catching errors.
  - If parsing fails or content-type is not JSON, returns `undefined` instead of throwing.

- `apiFetch<T>(path, init?)`:
  - Builds full URL: `baseUrl + path`.
  - Sets standard headers:
    - `Accept: application/json`.
    - `Content-Type: application/json` if a `json` property exists in `init`.
  - Serializes body if `init.json` is provided.
  - Performs `fetch`.
  - If status is `204`, returns `undefined` (type `T` expected to be `void`).
  - Tries to parse JSON body using `safeReadJson`.
  - If `res.ok` is false:
    - Extracts `detail` from the JSON body if available.
    - Throws `ApiError` with that message and status code.
  - On success, returns parsed body as type `T`.


3.8. Typed HRMS API client: `api/hrms.ts`
-----------------------------------------

Defines TypeScript types mirrored from backend schemas:

- `Employee`:
  - `employee_id`, `full_name`, `email`, `department`, `created_at`.

- `AttendanceStatus` union:
  - `'Present' | 'Absent'`.

- `AttendanceRecord`:
  - `date`, `status`, `created_at`.

- `Dashboard`:
  - `employee_count`, `attendance_records`, `today_present`, `today_absent`, `today_date`.

For each backend endpoint, a function is provided:

- `getDashboard()`: `GET /dashboard`
- `listEmployees()`: `GET /employees`
- `createEmployee({ employee_id, full_name, email, department })`: `POST /employees`
- `deleteEmployee(employeeId)`: `DELETE /employees/{employee_id}`
- `listAttendance({ employee_id, start_date?, end_date?, status? })`: `GET /employees/{employee_id}/attendance` with query params
- `markAttendance({ employee_id, date, status })`: `POST /employees/{employee_id}/attendance`

This layer centralizes all HTTP logic in one place and ensures pages work with strongly typed data.


3.9. Toast notifications: `components/ToastProvider.tsx`
--------------------------------------------------------

Purpose:
- Provide a global way to show transient messages for:
  - Success (e.g., "Employee added").
  - Errors (e.g., "Failed to load employees").

Implementation:

- `ToastPayload`:
  - `title: string`, `message?: string`.

- `ToastContext`:
  - Holds a single method `showToast(payload)`.

- `ToastProvider`:
  - Maintains `toast` state (either `null` or the current toast payload).
  - `showToast` sets `toast` and schedules `setToast(null)` after 4.2 seconds.
  - Renders:
    - `props.children`
    - A `.toast` element at bottom-right if `toast` is not null.

- `useToast()` hook:
  - Accesses the context; throws if used outside provider to avoid misuse.

Usage:
- `App.tsx` wraps the entire app in `<ToastProvider>`.
- Pages import `useToast` and call `.showToast({ title, message })` to display feedback.


3.10. Top-level App and routing (`App.tsx`)
-------------------------------------------

Responsibilities:
- Define global layout:
  - Topbar with title and nav.
  - Container for page content.
  - Display API base URL.
- Define SPA routes.

Implementation:

- `NavLink` from `react-router-dom` is used for navigation:
  - `to="/"` for dashboard.
  - `to="/employees"` for employees list.
  - Nav links use `className={cxNav}`, where `cxNav` returns `'active'` when the route is active; CSS uses `.nav a.active` to style.

- Routes:
  - `/` -> `DashboardPage`
  - `/employees` -> `EmployeesPage`
  - `/employees/:employeeId` -> `AttendancePage`
  - `*` -> Not found card

- The API base URL is shown under the topbar via `getApiBaseUrl()`, so one can easily confirm which backend endpoint is being used (useful in deployments where misconfigured envs cause issues).


3.11. Dashboard page (`DashboardPage.tsx`)
------------------------------------------

Purpose:
- Provide a basic admin overview (bonus feature).

Behavior:
- On mount (`useEffect` with empty dependency array apart from stable `showToast`), it:
  - Sets loading state.
  - Calls `getDashboard()`.
  - On success:
    - Stores `Dashboard` data in state.
  - On failure:
    - Extracts human-readable message from `ApiError`, or falls back to generic string.
    - Sets `error` state.
    - Shows toast `"Dashboard error"`.
  - Always clears `loading` when request completes.

UI:
- A single `.card` with:
  - Title "Dashboard".
  - Subtitle describing its purpose.
  - If `loading`: text "Loading dashboard…".
  - If `error`: error message + small "Reload" button (reloads the entire page).
  - If data present:
    - A grid of Stat cards showing:
      - Employees count.
      - Attendance records count.
      - Today Present.
      - Today Absent.
  - Each `Stat` card:
    - Has title, big number, and subtitle.
    - Uses lightly different border and background colors for good/bad metrics (e.g. green for present, red for absent).


3.12. Employees page (`EmployeesPage.tsx`)
------------------------------------------

Responsibilities:
- Show a table of all employees (list view).
- Provide a form to add a new employee.
- Provide actions:
  - Navigate to Attendance page for a given employee.
  - Delete employee.

State:
- `employees: Employee[]`
- `loading: boolean`
- `error: string | null`
- `form: { employee_id, full_name, email, department }`
- `saving: boolean` for the create action.

Data loading:
- `refresh()`:
  - Sets `loading = true`, clears `error`.
  - Calls `listEmployees()`.
  - On success: populates `employees`.
  - On failure:
    - Updates `error`.
    - Shows toast `"Employees error"`.
  - Finally: `loading = false`.

- `useEffect` on mount calls `refresh()` once.

Create employee:
- Form submission `onCreate`:
  - Prevents default form submit.
  - Sets `saving = true`.
  - Calls `createEmployee` with trimmed inputs.
  - On success:
    - Shows toast `"Employee added"` with name + employee_id.
    - Resets form to initial values.
    - Calls `refresh()` to update list.
  - On failure:
    - Maps error to string (status, etc.).
    - Shows toast `"Create failed"` with message.
  - Finally:
    - `saving = false`.

Delete employee:
- `onDelete(emp)`:
  - Shows confirmation dialog using `window.confirm`.
  - If confirmed:
    - Calls `deleteEmployee(emp.employee_id)`.
    - On success:
      - Displays `"Employee deleted"` toast.
      - Calls `refresh()` to update list.
    - On failure:
      - Shows `"Delete failed"` toast.

UI layout:
- Uses `.grid` for two columns:
  - Left: card containing employees list.
  - Right: card containing the add employee form.

Table:
- Shows:
  - Employee ID (bold)
  - Full Name
  - Email
  - Department
  - Actions:
    - `Attendance` button -> navigates to `/employees/{employee_id}`.
    - `Delete` button -> triggers deletion.

Empty/Loading/Error states:
- If `loading`: show "Loading employees…".
- If `error`: show error text in muted style.
- If not loading and not error and no employees: show empty state "No employees yet. Add your first employee on the right."

Form:
- Includes fields for each employee property.
- Provides placeholders for guidance.
- Submit button label is `"Saving…"` when `saving = true`.
- Form uses HTML5 `required` attributes for basic validation; server still re-validates.


3.13. Attendance page (`AttendancePage.tsx`)
-------------------------------------------

Responsibilities:
- Display all attendance records for a given employee.
- Allow filtering:
  - By start date.
  - By end date.
  - By Present/Absent.
- Provide a form to mark new attendance for that employee.

Param:
- Reads `employeeId` from URL via `useParams()` (React Router).
  - Decodes via `decodeURIComponent` to handle IDs with special chars.

State:
- For attendance records:
  - `rows: AttendanceRecord[]`
  - `loading: boolean`
  - `error: string | null`

- For filters:
  - `startDate: string`
  - `endDate: string`
  - `status: '' | AttendanceStatus`

- For mark-attendance form:
  - `markDate: string` (initialized to today’s date using `todayISO()` helper).
  - `markStatus: AttendanceStatus` (default `'Present'`).
  - `saving: boolean`

- Derived:
  - `presentCount = rows.filter(r => r.status === 'Present').length`
    - Used to show "X present days" summary for the current filtered dataset.

Data loading:
- `refresh()`:
  - If `employeeId` missing, returns early.
  - Sets `loading = true`, clears `error`.
  - Calls `listAttendance()` with:
    - `employee_id`
    - `start_date` or `undefined`
    - `end_date` or `undefined`
    - `status` or `undefined`
  - On success: sets `rows`.
  - On failure:
    - Sets `error`.
    - Shows toast `"Attendance error"`.
  - Finally: `loading = false`.

- `useEffect`:
  - On `employeeId` change, calls `refresh()` once.

Filter behavior:
- UI has three inputs:
  - Start date (type="date").
  - End date (type="date").
  - Status dropdown (All, Present, Absent).
- "Apply filters" button calls `refresh()` which re-fetches attendance with the new filters.

Mark attendance:
- `onMark(e)`:
  - Prevents default form submission.
  - If `employeeId` missing, returns.
  - Sets `saving = true`.
  - Calls `markAttendance` with:
    - `employee_id`, `markDate`, `markStatus`.
  - On success:
    - Shows toast `"Attendance saved"` with details.
    - Calls `refresh()` to update list.
  - On failure:
    - Shows `"Mark failed"` toast.
  - Finally: `saving = false`.

UI:
- Two cards in `.grid`:
  - Left: "Attendance" list and filters.
  - Right: "Mark attendance" form.

Left card header:
- Shows:
  - Employee ID.
  - Present count for current filter view.
  - "Back" button -> navigates back to `/employees`.
  - "Refresh" button.

Table:
- Columns:
  - Date (bold).
  - Status:
    - Rendered using `.pill` with `.pillPresent` or `.pillAbsent`.
  - Recorded at (formatted with `toLocaleString()`).

Empty/Loading/Error:
- If `loading`: "Loading attendance…".
- If `error`: shows error text.
- If no rows and no error: "No attendance records found for this employee (with the current filters)."

Right card:
- Form:
  - Date input defaulted to today.
  - Status dropdown (Present/Absent).
  - Submit button disabled if saving or missing `employeeId`.
  - When `employeeId` is missing, a muted message indicates that.


3.14. Routing config for deployment (`vercel.json` and `_redirects`)
--------------------------------------------------------------------

For this React SPA, client-side routing is used, so:
- Direct navigation to `/employees` or `/employees/EMP-001` must still serve `index.html`.

Files:
- `frontend/vercel.json`:
  - `"rewrites": [{ "source": "/(.*)", "destination": "/index.html" }]`
  - Tells Vercel that for any path, serve `index.html`, leaving routing to React Router.

- `frontend/public/_redirects`:
  - `/*    /index.html   200`
  - Tells Netlify to rewrite all routes to `index.html`.


4. ROOT-LEVEL SUPPORT FILES
---------------------------

4.1. .gitignore
---------------

At root:
- Ignores:
  - `.DS_Store`
  - Python artifacts: `__pycache__/`, `*.pyc`, `*.pyo`, `.venv`, `env/`, etc.
  - Local env files: `.env`, `.env.*`
  - DB files: `*.db`, `*.sqlite`, `*.sqlite3`
  - Node/JS artifacts: `node_modules/`, `dist/`, `.vite/`, log files

Reason:
- Keeps the repository clean.
- Avoids committing secrets or local DB data.


4.2. README.md
--------------

The README includes:
- Project overview and scope.
- Tech stack description for frontend+backend.
- API endpoints summary.
- Local run commands for backend and frontend.
- Environment variable explanations.
- Deployment guidance:
  - Backend on Render/Railway using Docker or direct `uvicorn`.
  - Frontend on Vercel/Netlify with correct VITE_API_BASE_URL.
- Assumptions and limitations:
  - Single admin user (no authentication).
  - One attendance record per employee per date.
  - SQLite default with option to change `DATABASE_URL`.


5. DEVELOPMENT AND VERIFICATION STEPS
------------------------------------

5.1. Step-by-step process we followed
------------------------------------

1. Verified current working directory is the assignment folder.
2. Created `backend/` and `backend/app/` directories.
3. Added Python backend dependencies in `backend/requirements.txt`.
4. Created `backend/.env.example` with database URL and CORS settings.
5. Implemented DB engine and session (`db.py`).
6. Implemented models (`Employee`, `Attendance`, and `AttendanceStatus`) in `models.py`.
7. Implemented request/response schemas in `schemas.py`.
8. Implemented `main.py`:
   - FastAPI instance.
   - CORS configuration.
   - Startup DB initialization.
   - Custom validation error handler.
   - REST endpoints for:
     - health
     - employees (POST/GET/DELETE)
     - attendance (POST/GET)
     - dashboard (GET)
9. Marked `backend/app` as a Python package with `__init__.py`.
10. Scaffoled `frontend/` using Vite React-TS template.
11. Installed frontend dependencies: React, ReactDOM, React Router, and TypeScript types.
12. Configured Vite with `@vitejs/plugin-react-swc` and port 5173.
13. Updated `tsconfig.json` with React JSX support and strict settings.
14. Added `frontend/.env.example` with `VITE_API_BASE_URL`.
15. Adjusted `index.html` to reference `main.tsx` and set proper title.
16. Created `src/main.tsx` as React entry, wrapping `App` in `BrowserRouter` and `ToastProvider`.
17. Created `src/api/http.ts`:
    - Centralized HTTP logic, error handling, and base URL resolution.
18. Created `src/api/hrms.ts`:
    - Encoded all backend endpoints and types.
19. Created `ToastProvider` component for global toasts.
20. Designed and implemented `DashboardPage`, `EmployeesPage`, and `AttendancePage` to:
    - Match requirements (employee and attendance management).
    - Provide clear loading, empty, and error states.
    - Implement bonus features:
      - Dashboard summary.
      - Attendance filters.
      - Present-day counts.
21. Removed unused Vite demo files (`main.ts`, `counter.ts`, `typescript.svg`).
22. Installed frontend Node modules using `npm install`.
23. Installed backend Python dependencies via `pip install -r backend/requirements.txt`.
24. Ran manual DB initialization tests and constraints tests using `python -c` one-liners.
25. Ensured DB file `hrms.db` is git-ignored; deleted any example DB after tests.
26. Created Dockerfile and .dockerignore for backend.
27. Created Vercel and Netlify routing config files for frontend.
28. Wrote comprehensive `README.md`.
29. Built frontend with `npm run build` and fixed any TypeScript issues (e.g. unused `React` imports, type-only imports).
30. Verified backend compiles with `py_compile` to catch syntax errors.
31. Finally, created this `procedure.txt` to record all of these steps and decisions in detail.


5.2. How to run and interact with the system
--------------------------------------------

Locally:
- Start backend:
  - `cd backend`
  - `python -m pip install -r requirements.txt`
  - `copy .env.example .env` and adjust if needed.
  - `python -m uvicorn app.main:app --host 0.0.0.0 --port 8000`
  - Visit `http://localhost:8000/docs` for interactive API docs.

- Start frontend:
  - `cd frontend`
  - `npm install`
  - `copy .env.example .env` and ensure `VITE_API_BASE_URL=http://localhost:8000`.
  - `npm run dev`
  - Visit `http://localhost:5173` in the browser.

Functional flow:
- Dashboard:
  - Initially, shows counts of employees and attendance (zero at first).
- Employees:
  - Add new employee using the form.
  - Then see them appear in the table.
  - Use "Attendance" button to go to their attendance page.
  - Use "Delete" button to remove them (and their attendance).
- Attendance:
  - For a given employee, mark them Present/Absent for specific dates.
  - Try to re-mark the same date to see a duplicate-handling error (handled with 409).
  - Use filters to view only present or absent days, or a specific date range.


6. SUMMARY
----------

This project delivers:
- A fully working, deployment-ready HRMS Lite system.
- Clean separation between backend and frontend.
- Strong validation and error handling on the backend.
- Professional, responsive admin UI with clear states and feedback on the frontend.

This `procedure.txt` documents all major and many minor decisions, making the full build process transparent and reproducible.

